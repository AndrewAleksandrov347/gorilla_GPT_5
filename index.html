<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1 горилла против 100 — джунгли</title>
  <meta name="description" content="Аркада: одна горилла против ста людей. HTML5 Canvas." />
  <style>
    :root{ --bg-0:#07140f; --bg-1:#0b2118; --leaf:#1f6a3e; --leaf-2:#2d8a57; --dirt:#3a2a1d;
      --path:#4a3727; --hud:#eaf7ef; --hud-dim:#b5d0bd; --accent:#9ee8b6; --warn:#ffb37a; --bad:#ff8484; }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 700px at 20% 0%,#10271a 0%,var(--bg-1) 45%,var(--bg-0) 100%);
      color:var(--hud);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
    .wrap{display:flex;align-items:center;justify-content:center;min-height:100%;padding:16px}
    .game{position:relative;width:min(1000px,96vw);aspect-ratio:16/9;border-radius:18px;
      box-shadow:0 16px 50px rgba(0,0,0,.55),inset 0 0 0 1px rgba(255,255,255,.06);
      background:linear-gradient(180deg,var(--bg-1),var(--bg-0));overflow:hidden}
    canvas{width:100%;height:100%;display:block}
    .screen{position:absolute;inset:0;display:none;align-items:center;justify-content:center}
    .screen.active{display:flex}
    .panel{background:rgba(5,12,9,.85);backdrop-filter:blur(8px);border:1px solid rgba(255,255,255,.06);
      border-radius:16px;padding:20px 22px;max-width:86%;box-shadow:0 18px 60px rgba(0,0,0,.6)}
    h1{margin:0 0 8px;font-weight:900;letter-spacing:.3px}
    .subtitle{color:var(--hud-dim);margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    button{cursor:pointer;border:1px solid rgba(255,255,255,.12);background:#0e1b14;color:var(--hud);
      border-radius:12px;padding:10px 14px;font-weight:800}
    button:hover{border-color:rgba(255,255,255,.22)}
    .accent{border-color:rgba(158,232,182,.45);box-shadow:0 0 0 2px rgba(158,232,182,.12) inset}
    .hint{font-size:14px;color:var(--hud-dim);margin-top:8px}
    .stats{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;color:#d6f0dd}
    .badge{display:inline-block;border:1px dashed rgba(255,255,255,.18);border-radius:999px;padding:6px 10px;
      font-size:12px;color:#d6f0dd;margin:4px 6px 0 0}
    .hud{position:absolute;left:12px;top:12px;display:flex;gap:12px;align-items:center;z-index:1}
    .hud .box{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:6px 10px;font-weight:800}
    .hud .danger{box-shadow:0 0 0 2px rgba(255,132,132,.18) inset;border-color:rgba(255,132,132,.35)}
    .topright{position:absolute;right:12px;top:12px;display:flex;gap:8px}
    .pill{padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);color:#d6f0dd;background:rgba(0,0,0,.25)}
    .testlog{position:absolute;left:12px;bottom:12px;max-width:60%;background:rgba(0,0,0,.25);
      border:1px dashed rgba(255,255,255,.15);padding:8px 10px;border-radius:10px;font-size:13px;
      max-height:180px;overflow:auto;display:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game" id="game">
      <canvas id="canvas" width="960" height="540" aria-label="Игровое поле"></canvas>

      <div class="hud" id="hud" hidden>
        <div class="box" id="hudScore">Счёт: 0</div>
        <div class="box" id="hudLives">Жизни: 3</div>
        <div class="box" id="hudWave">Волна: 1/10</div>
        <div class="box" id="hudLeft">Осталось: 100</div>
      </div>
      <div class="topright" id="topright" hidden>
        <div class="pill" id="hudDiff"></div>
        <div class="pill">↑/↓ — дорожки • Пробел — схватить/бросить</div>
      </div>

      <div class="screen active" id="screenStart">
        <div class="panel">
          <h1>1 горилла против 100 человек</h1>
          <div class="subtitle">Джунгли шумят. Слева — горилла. Справа — толпа.</div>
          <div class="stats">
            <div>Управление:</div>
            <div>↑/↓ — смена дорожки</div>
            <div></div>
            <div>Пробел — схватить/бросить, камни можно перехватывать</div>
          </div>
          <p class="hint">Цепная реакция: брошенный сбивает тех, кого задевает. Столкновение — минус жизнь. Всего 100.</p>
          <p style="margin:10px 0 6px">Сложность:</p>
          <div class="row">
            <button class="btnDiff" data-diff="easy">Лёгко</button>
            <button class="btnDiff accent" data-diff="normal">Норма</button>
            <button class="btnDiff" data-diff="hard">Тяжело</button>
            <button id="btnPractice" title="10 человек, без записи рекорда">Тренировка</button>
          </div>
          <p class="hint">Лучший счёт: <span id="bestScore">—</span></p>
        </div>
      </div>

      <div class="screen" id="screenOver">
        <div class="panel">
          <h1 id="overTitle">Раунд завершён</h1>
          <div class="stats">
            <div>Счёт:</div> <div id="overScore">0</div>
            <div>Жизни:</div> <div id="overLives">0</div>
            <div>Волны:</div> <div id="overWaves">0/10</div>
            <div>Убито/Всего:</div> <div id="overKilled">0/0</div>
          </div>
          <div id="medals" style="margin-top:8px"></div>
          <p class="hint" id="bestLine">Лучший счёт: —</p>
          <div class="row" style="margin-top:10px">
            <button id="btnAgain" class="accent">Снова</button>
            <button id="btnMenu">Меню</button>
          </div>
        </div>
      </div>

      <div id="testlog" class="testlog"></div>
    </div>
  </div>

<script>
(() => {
  "use strict";
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const hud = {
    root: document.getElementById('hud'),
    score: document.getElementById('hudScore'),
    lives: document.getElementById('hudLives'),
    wave: document.getElementById('hudWave'),
    left: document.getElementById('hudLeft'),
    diff: document.getElementById('hudDiff'),
    tr: document.getElementById('topright'),
  };
  const screenStart = document.getElementById('screenStart');
  const screenOver  = document.getElementById('screenOver');
  const bestScoreEl = document.getElementById('bestScore');
  const bestLine = document.getElementById('bestLine');
  const over = {
    title: document.getElementById('overTitle'),
    score: document.getElementById('overScore'),
    lives: document.getElementById('overLives'),
    waves: document.getElementById('overWaves'),
    killed: document.getElementById('overKilled'),
    medals: document.getElementById('medals'),
    again: document.getElementById('btnAgain'),
    menu: document.getElementById('btnMenu'),
  };

  // Кнопки
  document.querySelectorAll('.btnDiff').forEach(btn => btn.addEventListener('click', () => startGame(btn.dataset.diff)));
  document.getElementById('btnPractice').addEventListener('click', () => startGame('practice'));
  over.again.addEventListener('click', () => startGame(lastDiff || 'normal'));
  over.menu.addEventListener('click', backToMenu);

  // Безопасный localStorage
  const BEST_KEY = 'gv100_best';
  function safeGetLS(key){ try{ return window.localStorage ? window.localStorage.getItem(key) : null; }catch(e){ return null; } }
  function safeSetLS(key,val){ try{ if(window.localStorage) window.localStorage.setItem(key,val); }catch(e){} }
  let _bestMem = 0;
  function loadBest(){ const fromLS = safeGetLS(BEST_KEY); const v = +(fromLS ?? _bestMem ?? 0) || 0; _bestMem = Math.max(_bestMem, v); bestScoreEl.textContent = v; return v; }
  function saveBest(score){ const prev = loadBest(); if(score>prev){ _bestMem = score; safeSetLS(BEST_KEY, String(score)); } }
  let lastDiff = 'normal'; loadBest();

  // DPI
  function fitHiDPI(){
    const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    const rect = canvas.getBoundingClientRect();
    const w = Math.floor(rect.width), h = Math.floor(rect.height);
    if(canvas.width !== w*dpr || canvas.height !== h*dpr){
      canvas.width = w*dpr; canvas.height = h*dpr; ctx.setTransform(dpr,0,0,dpr,0,0);
    }
  }
  if (window.ResizeObserver) { new ResizeObserver(fitHiDPI).observe(canvas); } else { window.addEventListener('resize', fitHiDPI); }
  fitHiDPI();

  // Состояние
  const STATE = { MENU:0, PLAY:1, OVER:2 }; let state = STATE.MENU;
  const DIFF = {
    easy:   { name:'Лёгко', lives:3, lanes:4, total:100, waves:10, startThrowersWave:6, spawnBase:900, speedMul:0.85, throwerTele:0.9, catchWindow:0.20, gorillaSpeed:1.0 },
    normal: { name:'Норма', lives:3, lanes:4, total:100, waves:10, startThrowersWave:3, spawnBase:800, speedMul:1.00, throwerTele:0.7, catchWindow:0.14, gorillaSpeed:1.0 },
    hard:   { name:'Тяжело',lives:2, lanes:4, total:100, waves:10, startThrowersWave:2, spawnBase:720, speedMul:1.15, throwerTele:0.55, catchWindow:0.11, gorillaSpeed:1.05 },
    practice:{ name:'Тренировка', lives:3, lanes:4, total:10,  waves:2,  startThrowersWave:99, spawnBase:900, speedMul:0.95, throwerTele:0.9, catchWindow:0.25, gorillaSpeed:1.0, practice:true }
  };

  const LANE_H = 104; const BASELINE_Y = 100; const FIELD_L = 96;
  const gorilla = { lane:1, lanes:4, x:FIELD_L, w:60, h:56, invul:0, speed:420, holding:null, t:0 };
  const enemies=[]; const projectiles=[]; const stones=[]; const leaves=[]; const parallax={t1:[],t2:[],vines:[]};

  let score=0, lives=3, wave=1, totalToSpawn=100, spawned=0, killed=0, escaped=0, processed=0; let waves=10, spawnTimer=0, spawnInterval=900, gameTime=0, difficulty=DIFF.normal;

  const keys = new Set(); let keyLatch={up:false,down:false,space:false};
  window.addEventListener('keydown', (e)=>{ if(e.code==='ArrowUp'||e.code==='ArrowDown'||e.code==='Space'){ e.preventDefault(); } keys.add(e.code); });
  window.addEventListener('keyup',   (e)=>{ keys.delete(e.code); });

  // Утилиты графики
  const rnd=(a,b)=>a + Math.random()*(b-a);
  function laneY(i){ return BASELINE_Y + i*LANE_H; }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }

  function drawDirtStrip(y,h,w){ ctx.fillStyle = '#3a2a1d'; ctx.fillRect(0,y,w,h); ctx.globalAlpha=.08; ctx.fillStyle='#000'; for(let i=0;i<60;i++){ ctx.fillRect(rnd(0,w), rnd(y,y+h), 1, 1); } ctx.globalAlpha=1; }
  function drawGrassClump(x,y,scale){ ctx.save(); ctx.translate(x,y); ctx.scale(scale,scale); ctx.fillStyle = '#1e6b3e'; for(let i=0;i<6;i++){ const a = -0.8 + i*0.32; ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(Math.cos(a)*8, -10 + Math.sin(a)*2, Math.cos(a)*12, -2); ctx.strokeStyle = '#2a8a56'; ctx.lineWidth=2; ctx.stroke(); } ctx.restore(); }
  function drawLeaf(x,y,rot,s,shade){ ctx.save(); ctx.translate(x,y); ctx.rotate(rot); ctx.scale(s,s); ctx.beginPath(); ctx.moveTo(0,0); ctx.quadraticCurveTo(16,-10, 22,0); ctx.quadraticCurveTo(16,10, 0,0); ctx.fillStyle = shade? '#2a8a56' : '#1f6a3e'; ctx.fill(); ctx.restore(); }
  function drawGodRays(w,h){ ctx.save(); ctx.globalAlpha=.06; ctx.fillStyle = '#e7fbefff'; for(let i=0;i<4;i++){ ctx.beginPath(); const x0 = -80 + i*120; const y0=-40; ctx.moveTo(x0, y0); ctx.lineTo(x0+280, y0+0); ctx.lineTo(x0+580, y0+h*0.9); ctx.lineTo(x0+320, y0+h*0.9); ctx.closePath(); ctx.fill(); } ctx.restore(); }

  function buildParallax(w,h){ parallax.t1.length=0; parallax.t2.length=0; parallax.vines.length=0; for(let i=0;i<10;i++) parallax.t1.push({ x:rnd(0,w), h:rnd(90,160) }); for(let i=0;i<8;i++) parallax.t2.push({ x:rnd(0,w), h:rnd(140,220) }); for(let i=0;i<6;i++) parallax.vines.push({ x:rnd(40,w-40), top:rnd(0,80), len:rnd(80,160) }); }
  function drawParallax(w,h,dt){ const speed1=8, speed2=16; for(const t of parallax.t1){ t.x -= speed1*dt; if(t.x < -20) t.x += w+40; } for(const t of parallax.t2){ t.x -= speed2*dt; if(t.x < -20) t.x += w+40; } ctx.fillStyle = '#0f2a1e'; for(const t of parallax.t1){ drawRoundedRect(t.x-12, 40, 24, t.h, 10); ctx.fill(); } ctx.fillStyle = '#17402d'; for(const t of parallax.t2){ drawRoundedRect(t.x-14, 30, 28, t.h, 12); ctx.fill(); } ctx.strokeStyle = '#1c5a3a'; ctx.lineWidth=3; ctx.lineCap='round'; for(const v of parallax.vines){ ctx.beginPath(); ctx.moveTo(v.x, v.top); const mid = v.top + v.len*0.6; ctx.bezierCurveTo(v.x-30, v.top+v.len*0.2, v.x+30, mid, v.x, v.top+v.len); ctx.stroke(); for(let k=0;k<4;k++) drawLeaf(v.x + rnd(-14,14), v.top + (k+1)*v.len/5, rnd(-.5,.5), rnd(0.7,1.2), k%2); } }
  function spawnLeaf(w){ leaves.push({ x:rnd(0,w), y:-10, vy:rnd(20,40), vx:rnd(-12,12), rot:0, vr:rnd(-0.8,0.8), s:rnd(0.6,1.1) }); }
  function drawLeaves(w,h,dt){ if(Math.random()<0.04) spawnLeaf(w); for(let i=leaves.length-1;i>=0;i--){ const L=leaves[i]; L.x+=L.vx*dt; L.y+=L.vy*dt; L.rot+=L.vr*dt; drawLeaf(L.x,L.y,L.rot,L.s,(i%2)===0); if(L.y>h+20) leaves.splice(i,1); } }

  // Новое изображение гориллы
  function drawGorilla(){
    const y = laneY(gorilla.lane);
    const breath = Math.sin(gorilla.t*3)*1.2;
    ctx.fillStyle='rgba(0,0,0,.38)'; ctx.beginPath(); ctx.ellipse(gorilla.x+18, y+24, 34, 11, 0, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(gorilla.x, y+breath);
    ctx.fillStyle = '#2b3f35'; drawRoundedRect(-26,-40, 56, 60, 14); ctx.fill();
    ctx.fillStyle = '#3c584b'; drawRoundedRect(-8,-8, 34, 30, 10); ctx.fill();
    ctx.fillStyle = '#31483d'; drawRoundedRect(16,-14, 26, 14, 7); ctx.fill();
    ctx.fillStyle = '#31483d'; drawRoundedRect(-30,-16, 24, 14, 7); ctx.fill();
    ctx.save(); ctx.translate(22,-30);
    ctx.fillStyle = '#2f463a'; drawRoundedRect(-4,-8, 24, 22, 8); ctx.fill();
    ctx.fillStyle = '#607d6d'; drawRoundedRect(2,-2, 16, 10, 4); ctx.fill();
    ctx.fillStyle = '#24352d'; ctx.fillRect(10,2,4,3);
    ctx.fillStyle = '#e9f4ee'; ctx.fillRect(4,-4,3,3); ctx.fillRect(14,-4,3,3);
    ctx.restore();
    if(gorilla.holding){
      ctx.fillStyle = '#31483d'; drawRoundedRect(18,-6, 26, 12, 6); ctx.fill();
      ctx.fillStyle = '#31483d'; drawRoundedRect(4,-8, 22, 12, 6); ctx.fill();
      ctx.fillStyle = gorilla.holding.kind==='stone'? '#b2966a' : '#f3c79c';
      ctx.beginPath(); ctx.arc(44,-4, 10, 0, Math.PI*2); ctx.fill();
    }
    ctx.restore();
    if(gorilla.invul>0){ ctx.strokeStyle='rgba(255,180,180,.9)'; ctx.lineWidth=2; ctx.strokeRect(gorilla.x-30, y-50, 80, 80); }
  }

  function enemyColors(type){ switch(type){ case 'sprinter': return { body:'#f5d5b0', shirt:'#f0a96a' }; case 'zigzag': return { body:'#f0d0b0', shirt:'#c7e36d' }; case 'heavy': return { body:'#ecc8a3', shirt:'#d17c7c' }; case 'thrower': return { body:'#f0d7b8', shirt:'#98d3ff' }; default: return { body:'#f0d7b8', shirt:'#d0c47a' }; } }
  function drawEnemy(e){ const y=laneY(e.lane); const c=enemyColors(e.type); ctx.fillStyle='rgba(0,0,0,.32)'; ctx.beginPath(); ctx.ellipse(e.x, y+18, 22, 8, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#27221a'; ctx.fillRect(e.x-10, y-8, 8, 16); ctx.fillRect(e.x+2, y-8, 8, 16); ctx.fillStyle=c.shirt; drawRoundedRect(e.x-12, y-28, 24, 26, 6); ctx.fill(); ctx.fillStyle=c.body; ctx.beginPath(); ctx.arc(e.x, y-36, 8, 0, Math.PI*2); ctx.fill(); if(e.type==='thrower' && e.state==='tele'){ ctx.fillStyle='#ffe08a'; ctx.beginPath(); ctx.arc(e.x, y-48, 6, 0, Math.PI*2); ctx.fill(); } }
  function drawProjectile(p){ const y=laneY(p.lane); if(p.kind==='stone'){ const g=ctx.createRadialGradient(p.x-3,y-20,2, p.x,y-18,p.r); g.addColorStop(0,'#e2d2ad'); g.addColorStop(1,'#b2966a'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x, y-18, p.r, 0, Math.PI*2); ctx.fill(); } else { ctx.fillStyle='#f3c79c'; ctx.beginPath(); ctx.arc(p.x, y-18, p.r, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='rgba(0,0,0,.15)'; ctx.stroke(); } ctx.globalAlpha=.10; ctx.fillStyle='#eaf7ef'; ctx.fillRect(p.x-24, y-20, 24, 4); ctx.globalAlpha=1; }
  function drawStone(s){ const y=laneY(s.lane); const g=ctx.createRadialGradient(s.x-3,y-20,2, s.x,y-18,8); g.addColorStop(0,'#e2d2ad'); g.addColorStop(1,'#a88a5f'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s.x, y-18, 8, 0, Math.PI*2); ctx.fill(); }

  function drawBackground(dt){
    const rect=canvas.getBoundingClientRect(); const w=rect.width, h=rect.height;
    const g=ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,'#0e261a'); g.addColorStop(0.5,'#0a2016'); g.addColorStop(1,'#08140f'); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    drawGodRays(w,h); drawParallax(w,h,dt);
    const groundTop=BASELINE_Y-36; drawDirtStrip(groundTop, h-groundTop, w);
    for(let i=0;i<gorilla.lanes;i++){
      const y=laneY(i);
      ctx.globalAlpha=.9; ctx.fillStyle = '#4a3727'; drawRoundedRect(0, y-28, w, 56, 8); ctx.fill(); ctx.globalAlpha=1;
      for(let k=0;k<8;k++){ drawGrassClump((w/8)*k + rnd(0,40), y-28, rnd(0.6,1.1)); drawGrassClump((w/8)*k + rnd(0,40), y+28, rnd(0.5,0.9)); }
    }
    drawLeaves(w,h,dt);
  }

  // Игровая логика
  function spawnEnemy(){
    if(spawned >= totalToSpawn) return;
    const lane = Math.floor(Math.random()*gorilla.lanes);
    const wv=wave; const allowThrower = (wv >= difficulty.startThrowersWave);
    const pool=[];
    pool.push(['runner',50]);
    pool.push(['sprinter',10 + Math.max(0,wv-3)*4]);
    pool.push(['zigzag',   8  + Math.max(0,wv-2)*3]);
    pool.push(['heavy',    8  + Math.max(0,wv-4)*3]);
    if(allowThrower) pool.push(['thrower', 6 + Math.max(0,wv-5)*3]);
    const sum = pool.reduce((s,[,v])=>s+v,0);
    let r=Math.random()*sum, type='runner';
    for(const [t,v] of pool){ r-=v; if(r<=0){ type=t; break; } }

    const baseSpeed=92 * difficulty.speedMul;
    let speed=baseSpeed;
    if(type==='sprinter') speed*=1.9; else if(type==='heavy') speed*=0.64; else if(type==='thrower') speed*=0.95; else if(type==='zigzag') speed*=1.07;
    const rect=canvas.getBoundingClientRect();
    const e={ type, lane, x: rect.width + 40, w:22, h:34, speed, zigTimer: 0.6 + Math.random()*0.6, state:'run', teleTimer:difficulty.throwerTele, stopX: Math.max(320, 520 - wv*8 + Math.random()*60), };
    enemies.push(e); spawned++;
  }
  function rectsOverlap(ax,aw,bx,bw){ return Math.abs(ax-bx) < (aw/2 + bw/2); }

  let lastTs=0;
  function loop(ts){
    requestAnimationFrame(loop);
    if(state!==STATE.PLAY) return;
    fitHiDPI();
    const rect=canvas.getBoundingClientRect(); const w=rect.width, h=rect.height;
    const dt=Math.min(0.033, (ts - lastTs)/1000 || 0); lastTs=ts; gameTime+=dt; gorilla.t += dt;

    if(keys.has('ArrowUp') && !keyLatch.up){ gorilla.lane=Math.max(0, gorilla.lane-1); keyLatch.up=true; }
    if(!keys.has('ArrowUp')) keyLatch.up=false;
    if(keys.has('ArrowDown') && !keyLatch.down){ gorilla.lane=Math.min(gorilla.lanes-1, gorilla.lane+1); keyLatch.down=true; }
    if(!keys.has('ArrowDown')) keyLatch.down=false;

    if(keys.has('Space') && !keyLatch.space){
      keyLatch.space=true;
      if(gorilla.holding){
        const p={ kind:gorilla.holding.kind, lane: gorilla.lane, x: gorilla.x+50, vx: 540, r: gorilla.holding.kind==='stone'? 8 : (gorilla.holding.mass==='heavy'? 12 : 10) };
        projectiles.push(p); gorilla.holding=null;
      } else {
        let target=null, minDx=9999; for(const e of enemies){ if(e.lane!==gorilla.lane) continue; const dx=e.x-(gorilla.x+22); if(dx>=-6 && dx<minDx && dx<62){ target=e; minDx=dx; } }
        if(target){ const idx=enemies.indexOf(target); if(idx>=0) enemies.splice(idx,1); gorilla.holding={ kind:'body', lane:gorilla.lane, mass: target.type==='heavy'?'heavy':'normal' }; processed++; }
        else{ for(let i=0;i<stones.length;i++){ const s=stones[i]; if(s.lane!==gorilla.lane) continue; const dx=Math.abs(s.x-(gorilla.x+24)); if(dx<26){ gorilla.holding={kind:'stone',lane:gorilla.lane}; stones.splice(i,1); break; } } }
      }
    }
    if(!keys.has('Space')) keyLatch.space=false;

    if(gorilla.invul>0) gorilla.invul = Math.max(0, gorilla.invul - dt);

    spawnTimer -= dt*1000;
    if(spawnTimer<=0){
      spawnEnemy();
      const waveP = (spawned)/(totalToSpawn);
      const waveIdx = Math.floor(waveP * waves) + 1;
      spawnInterval = difficulty.spawnBase - (waveIdx-1)*40;
      spawnTimer = Math.max(260, spawnInterval + (Math.random()*120-60));
    }

    for(let i=enemies.length-1;i>=0;i--){
      const e=enemies[i];
      if(e.type==='zigzag'){ e.zigTimer -= dt; if(e.zigzag<=0 || e.zigTimer<=0){ e.zigTimer=0.45+Math.random()*0.7; const dir=Math.random()<.5?-1:1; e.lane=Math.min(gorilla.lanes-1, Math.max(0, e.lane+dir)); } }
      if(e.type==='thrower'){
        if(e.state==='run'){ e.x -= e.speed*dt; if(e.x<=e.stopX){ e.state='tele'; e.teleTimer = difficulty.throwerTele; } }
        else if(e.state==='tele'){ e.teleTimer -= dt; if(e.teleTimer<=0){ e.state='throw'; } }
        else if(e.state==='throw'){ stones.push({ lane:e.lane, x:e.x-10, vx: -430 * difficulty.speedMul }); e.state='resume'; }
        else if(e.state==='resume'){ e.x -= e.speed*dt*0.95; }
      } else { e.x -= e.speed*dt; }

      if(e.lane===gorilla.lane && !gorilla.holding){
        if(rectsOverlap(e.x, 22, gorilla.x+18, 40)){
          if(gorilla.invul<=0){ lives--; gorilla.invul=0.9; flashLives(); }
          enemies.splice(i,1); processed++;
        }
      }
      if(e && e.x < -30){ enemies.splice(i,1); escaped++; processed++; }
    }

    for(let i=stones.length-1;i>=0;i--){
      const s=stones[i]; s.x += s.vx*dt;
      if(s.lane===gorilla.lane && Math.abs(s.x-(gorilla.x+22))<16){
        if(keys.has('Space') && !gorilla.holding){ gorilla.holding={kind:'stone',lane:gorilla.lane}; stones.splice(i,1); continue; }
        if(gorilla.invul<=0){ lives--; gorilla.invul=0.9; flashLives(); }
        stones.splice(i,1);
      }
      if(s.x < -40) stones.splice(i,1);
    }

    for(let i=projectiles.length-1;i>=0;i--){
      const p=projectiles[i]; p.x += p.vx*dt;
      for(let j=enemies.length-1;j>=0;j--){
        const e=enemies[j]; if(e.lane!==p.lane) continue;
        if(Math.abs(p.x - e.x) < (p.r + 11)){
          enemies.splice(j,1); killed++; processed++; score++;
          if(p.kind==='body' && p.r>10) p.vx *= 0.97;
        }
      }
      if(p.x > w+40) projectiles.splice(i,1);
    }

    const newWave = Math.floor(processed / Math.max(1, Math.ceil(totalToSpawn / waves))) + 1; wave = Math.min(waves, newWave);
    if(lives<=0 || processed>=totalToSpawn){ endRound(lives>0); return; }

    ctx.clearRect(0,0,w,h); drawBackground(dt);
    ctx.fillStyle='rgba(255,255,255,.12)'; const barH = Math.max(8, (totalToSpawn-processed)/totalToSpawn * (h-40));
    ctx.fillRect(w-10, 20, 4, h-40); ctx.fillStyle='#9ee8b6'; ctx.fillRect(w-10, 20 + (h-40 - barH), 4, barH);
    for(const e of enemies) drawEnemy(e); for(const s of stones) drawStone(s); for(const p of projectiles) drawProjectile(p); drawGorilla();
    hud.score.textContent = `Счёт: ${score}`; hud.lives.textContent = `Жизни: ${Math.max(0,lives)}`; hud.wave.textContent = `Волна: ${wave}/${waves}`; hud.left.textContent = `Осталось: ${Math.max(0,totalToSpawn-processed)}`;
  }

  function flashLives(){ hud.lives.classList.add('danger'); setTimeout(()=>hud.lives.classList.remove('danger'), 240); }
  function startGame(diffKey){
    lastDiff=diffKey; difficulty=DIFF[diffKey]||DIFF.normal; state=STATE.PLAY;
    screenStart.classList.remove('active'); screenOver.classList.remove('active');
    hud.root.hidden=false; hud.tr.hidden=false; hud.diff.textContent=difficulty.name;
    gorilla.lanes=difficulty.lanes; gorilla.lane=Math.floor(gorilla.lanes/2); gorilla.holding=null; gorilla.invul=0; gorilla.speed=420*difficulty.gorillaSpeed; gorilla.t=0;
    enemies.length=0; projectiles.length=0; stones.length=0; leaves.length=0;
    buildParallax(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
    score=0; lives=difficulty.lives; wave=1; totalToSpawn=difficulty.total; waves=difficulty.waves; spawned=0; killed=0; escaped=0; processed=0; gameTime=0;
    spawnTimer=300; spawnInterval=difficulty.spawnBase;
    fitHiDPI(); lastTs=performance.now(); requestAnimationFrame(loop);
  }
  function collectMedals(){ const medals=[]; if(killed>=80 && !difficulty.practice) medals.push('Гроза толпы (80+)'); if(lives===difficulty.lives && !difficulty.practice) medals.push('Без царапин'); if(score>=killed && score>0 && !difficulty.practice) medals.push('Каждый — броском'); if(difficulty.name==='Тяжело' && lives>0) medals.push('Железные нервы'); return medals; }
  function endRound(won){
    state=STATE.OVER; hud.root.hidden=true; hud.tr.hidden=true;
    over.title.textContent=(won?'Победа!':'Горилла пала…'); over.score.textContent=score; over.lives.textContent=Math.max(0,lives);
    over.waves.textContent=`${wave}/${waves}`; over.killed.textContent=`${killed}/${totalToSpawn}`;
    over.medals.innerHTML=''; for(const m of collectMedals()){ const s=document.createElement('span'); s.className='badge'; s.textContent=m; over.medals.appendChild(s);}
    if(!difficulty.practice){ saveBest(score);} bestLine.textContent='Лучший счёт: '+loadBest();
    screenOver.classList.add('active');
  }
  function backToMenu(){ state=STATE.MENU; hud.root.hidden=true; hud.tr.hidden=true; screenOver.classList.remove('active'); screenStart.classList.add('active'); loadBest(); }

  // Мини-тесты — открыть index.html#test
  function runTests(){
    const logEl = document.getElementById('testlog');
    const logs = []; const ok = (m)=>logs.push("✅ "+m); const fail=(m)=>logs.push("❌ "+m);
    // 1) пересечение
    rectsOverlap(10,10,18,10) ? ok("rectsOverlap: пересекаются") : fail("rectsOverlap: ожидали пересечение");
    !rectsOverlap(0,10,40,10) ? ok("rectsOverlap: не пересекаются") : fail("rectsOverlap: не должно пересекаться");
    // 2) метатели на высокой волне
    let got=false; const savedWave=wave; wave=6;
    for(let k=0;k<200;k++){ spawnEnemy(); const e=enemies.pop(); if(e && e.type==='thrower'){ got=true; break; } }
    wave=savedWave; got ? ok("spawnEnemy: метатели после нужной волны") : fail("spawnEnemy: нет метателя на волне >=6");
    // 3) захват учитывается
    const prevProcessed = processed; gorilla.lane=0;
    enemies.push({type:'runner', lane:0, x:gorilla.x+30, w:22, h:34, speed:0, zigTimer:1, state:'run', teleTimer:0, stopX:0});
    // эмуляция захвата (как в цикле)
    let target=null, minDx=9999; for(const e of enemies){ if(e.lane!==gorilla.lane) continue; const dx=e.x-(gorilla.x+22); if(dx>=-6 && dx<minDx && dx<62){ target=e; minDx=dx; } }
    if(target){ const idx=enemies.indexOf(target); if(idx>=0) enemies.splice(idx,1); gorilla.holding={ kind:'body', lane:gorilla.lane, mass:'normal' }; processed++; }
    (processed===prevProcessed+1) ? ok("Захват увеличивает processed") : fail("Захват должен увеличивать processed");
    logEl.style.display='block'; logEl.innerText = logs.join("\\n");
  }
  if(location.hash==="#test"){ runTests(); }

  // Красиво на старте
  fitHiDPI(); buildParallax(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
  (function first(){ const rect=canvas.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); const dt=0.016; drawBackground(dt); drawGorilla(); })();
})();
</script>
</body>
</html>
