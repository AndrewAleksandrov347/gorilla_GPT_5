<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>1 горилла против 100 — Комикс‑джунгли</title>
  <meta name="description" content="Аркада: одна горилла против ста людей. Стиль — комикс в джунглях. HTML5 Canvas." />
  <style>
    :root{
      /* Палитра «комикс в джунглях» */
      --bg-0:#0b1612;   /* фон нижний */
      --bg-1:#0f231a;   /* фон верхний */
      --canopy-far:#0c2a1e;    /* дальние кроны */
      --canopy-mid:#12402f;    /* средние кроны */
      --canopy-near:#1a5a41;   /* ближние кроны */
      --trunk:#2b3a2f;         /* стволы */
      --vine:#1b4b36;          /* лианы */

      --dirt:#3f2f23;   /* земля */
      --path:#4a3829;   /* дорожка */
      --path-hi:#6a4c36;/* верхний блик дорожки */
      --path-sh:#2b1f16;/* нижняя тень дорожки */

      --ink:#0a1813;    /* цвет обводки персонажей */

      --hud:#eaf7ef;    /* текст */
      --hud-dim:#b5d0bd;/* тусклый */
      --accent:#9ee8b6; /* акцент */
      --warn:#ffd166;   /* предупреждение (телеграф) */
      --bad:#ff8484;    /* урон */
    }

    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg-1),var(--bg-0));color:var(--hud);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial}
    .wrap{display:flex;align-items:center;justify-content:center;min-height:100%;padding:16px}
    .game{position:relative;width:min(1000px,96vw);aspect-ratio:16/9;border-radius:18px;box-shadow:0 16px 50px rgba(0,0,0,.55),inset 0 0 0 1px rgba(255,255,255,.06);background:transparent;overflow:hidden}
    canvas{width:100%;height:100%;display:block}

    .screen{position:absolute;inset:0;display:none;align-items:center;justify-content:center}
    .screen.active{display:flex}
    .panel{background:rgba(5,12,9,.88);backdrop-filter:blur(8px);border:2px solid rgba(255,255,255,.10);border-radius:16px;padding:20px 22px;max-width:86%;box-shadow:0 18px 60px rgba(0,0,0,.6)}
    h1{margin:0 0 8px;font-weight:900;letter-spacing:.3px}
    .subtitle{color:var(--hud-dim);margin-bottom:12px}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    button{cursor:pointer;border:2px solid rgba(255,255,255,.18);background:#11261d;color:var(--hud);border-radius:12px;padding:10px 14px;font-weight:900;box-shadow:0 4px 0 rgba(0,0,0,.35)}
    button:hover{border-color:rgba(255,255,255,.28)}
    .accent{border-color:rgba(158,232,182,.6);box-shadow:0 0 0 2px rgba(158,232,182,.16) inset, 0 4px 0 rgba(0,0,0,.35)}
    .hint{font-size:14px;color:var(--hud-dim);margin-top:8px}

    .hud{position:absolute;left:12px;top:12px;display:flex;gap:12px;align-items:center;z-index:1}
    .hud .box{background:rgba(0,0,0,.35);border:2px solid rgba(255,255,255,.10);border-radius:12px;padding:6px 10px;font-weight:900}
    .hud .danger{box-shadow:0 0 0 3px rgba(255,132,132,.18) inset;border-color:rgba(255,132,132,.45)}
    .topright{position:absolute;right:12px;top:12px;display:flex;gap:8px}
    .pill{padding:6px 10px;border-radius:999px;border:2px solid rgba(255,255,255,.12);color:#d6f0dd;background:rgba(0,0,0,.25)}

    /* внутренняя «комиксная» рамка */
    .game::after{content:"";position:absolute;inset:8px;border-radius:14px;border:3px solid rgba(0,0,0,.45);box-shadow:inset 0 0 0 2px rgba(255,255,255,.05);pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game" id="game">
      <canvas id="canvas" width="960" height="540" aria-label="Игровое поле"></canvas>

      <div class="hud" id="hud" hidden>
        <div class="box" id="hudScore">Счёт: 0</div>
        <div class="box" id="hudLives">Жизни: 3</div>
        <div class="box" id="hudWave">Волна: 1/10</div>
        <div class="box" id="hudLeft">Осталось: 100</div>
      </div>
      <div class="topright" id="topright" hidden>
        <div class="pill" id="hudDiff"></div>
        <div class="pill">↑/↓ — дорожки • Пробел — схватить/бросить</div>
      </div>

      <!-- Стартовый экран -->
      <div class="screen active" id="screenStart">
        <div class="panel">
          <h1>1 горилла против 100 человек</h1>
          <div class="subtitle">Комикс‑джунгли: слева — горилла, справа — толпа. Четыре дорожки.</div>
          <div class="stats" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;color:#d6f0dd">
            <div>Управление:</div>
            <div>Стрелка вверх/вниз — смена дорожки</div>
            <div></div>
            <div>Пробел — схватить/бросить, камни можно перехватывать</div>
          </div>
          <p class="hint">Цепная реакция: брошенный сбивает тех, кого задевает. Столкновение — минус жизнь. Всего 100.</p>
          <p style="margin:10px 0 6px">Сложность:</p>
          <div class="row">
            <button class="btnDiff" data-diff="easy">Лёгко</button>
            <button class="btnDiff accent" data-diff="normal">Норма</button>
            <button class="btnDiff" data-diff="hard">Тяжело</button>
            <button id="btnPractice" title="10 человек, без записи рекорда">Тренировка</button>
          </div>
          <p class="hint">Лучший счёт: <span id="bestScore">—</span></p>
        </div>
      </div>

      <!-- Экран паузы/меню -->
      <div class="screen" id="screenPause">
        <div class="panel">
          <h1>Пауза</h1>
          <p class="hint">Esc или P — продолжить. Можно вернуться в меню без потери прогресса.</p>
          <div class="row" style="margin-top:10px">
            <button id="btnResume" class="accent">Продолжить</button>
            <button id="btnToMenu">В меню</button>
          </div>
        </div>
      </div>

      <!-- Экран конца раунда -->
      <div class="screen" id="screenOver">
        <div class="panel">
          <h1 id="overTitle">Раунд завершён</h1>
          <div class="stats" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:10px;color:#d6f0dd">
            <div>Счёт:</div> <div id="overScore">0</div>
            <div>Жизни:</div> <div id="overLives">0</div>
            <div>Волны:</div> <div id="overWaves">0/10</div>
            <div>Убито/Всего:</div> <div id="overKilled">0/0</div>
          </div>
          <div id="medals" style="margin-top:8px"></div>
          <p class="hint" id="bestLine">Лучший счёт: —</p>
          <div class="row" style="margin-top:10px">
            <button id="btnAgain" class="accent">Снова</button>
            <button id="btnMenu">Меню</button>
          </div>
        </div>
      </div>

      <div id="testlog" class="testlog" style="position:absolute;left:12px;bottom:12px;max-width:60%;background:rgba(0,0,0,.25);border:1px dashed rgba(255,255,255,.15);padding:8px 10px;border-radius:10px;font-size:13px;max-height:180px;overflow:auto;display:none"></div>
    </div>
  </div>

<script>
(() => {
  'use strict';
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const hud = {
    root: document.getElementById('hud'),
    score: document.getElementById('hudScore'),
    lives: document.getElementById('hudLives'),
    wave: document.getElementById('hudWave'),
    left: document.getElementById('hudLeft'),
    diff: document.getElementById('hudDiff'),
    tr: document.getElementById('topright'),
  };
  const screenStart = document.getElementById('screenStart');
  const screenPause = document.getElementById('screenPause');
  const screenOver  = document.getElementById('screenOver');
  const bestScoreEl = document.getElementById('bestScore');
  const bestLine = document.getElementById('bestLine');
  const over = {
    title: document.getElementById('overTitle'),
    score: document.getElementById('overScore'),
    lives: document.getElementById('overLives'),
    waves: document.getElementById('overWaves'),
    killed: document.getElementById('overKilled'),
    medals: document.getElementById('medals'),
    again: document.getElementById('btnAgain'),
    menu: document.getElementById('btnMenu'),
  };

  // Кнопки
  document.querySelectorAll('.btnDiff').forEach(btn => btn.addEventListener('click', () => startGame(btn.dataset.diff)));
  document.getElementById('btnPractice').addEventListener('click', () => startGame('practice'));
  over.again.addEventListener('click', () => startGame(lastDiff || 'normal'));
  over.menu.addEventListener('click', backToMenu);
  document.getElementById('btnResume').addEventListener('click', resumeGame);
  document.getElementById('btnToMenu').addEventListener('click', () => { backToMenu(); });

  // Безопасный localStorage
  const BEST_KEY = 'gv100_best';
  function safeGetLS(key){ try{ return window.localStorage ? window.localStorage.getItem(key) : null; }catch(e){ return null; } }
  function safeSetLS(key,val){ try{ if(window.localStorage) window.localStorage.setItem(key,val); }catch(e){} }
  let _bestMem = 0;
  function loadBest(){ const fromLS = safeGetLS(BEST_KEY); const v = +(fromLS ?? _bestMem ?? 0) || 0; _bestMem = Math.max(_bestMem, v); bestScoreEl.textContent = v; return v; }
  function saveBest(score){ const prev = loadBest(); if(score>prev){ _bestMem = score; safeSetLS(BEST_KEY, String(score)); } }
  let lastDiff = 'normal'; loadBest();

  // DPI
  function fitHiDPI(){ const dpr = Math.max(1, Math.min(window.devicePixelRatio || 1, 2)); const rect = canvas.getBoundingClientRect(); const w = Math.floor(rect.width), h = Math.floor(rect.height); if(canvas.width !== w*dpr || canvas.height !== h*dpr){ canvas.width = w*dpr; canvas.height = h*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); } }
  if (window.ResizeObserver) { new ResizeObserver(fitHiDPI).observe(canvas); } else { window.addEventListener('resize', fitHiDPI); }
  fitHiDPI();

  // Состояние
  const STATE = { MENU:0, PLAY:1, OVER:2, PAUSE:3, DEATH:4 }; let state = STATE.MENU;
  const DIFF = {
    easy:   { name:'Лёгко', lives:3, lanes:4, total:100, waves:10, startThrowersWave:6, spawnBase:900, speedMul:0.85, throwerTele:0.9, catchWindow:0.20, gorillaSpeed:1.0 },
    normal: { name:'Норма', lives:3, lanes:4, total:100, waves:10, startThrowersWave:3, spawnBase:800, speedMul:1.00, throwerTele:0.7, catchWindow:0.14, gorillaSpeed:1.0 },
    hard:   { name:'Тяжело',lives:2, lanes:4, total:100, waves:10, startThrowersWave:2, spawnBase:720, speedMul:1.15, throwerTele:0.55, catchWindow:0.11, gorillaSpeed:1.05 },
    practice:{ name:'Тренировка', lives:3, lanes:4, total:10,  waves:2,  startThrowersWave:99, spawnBase:900, speedMul:0.95, throwerTele:0.9, catchWindow:0.25, gorillaSpeed:1.0, practice:true }
  };

  const LANE_H = 104; const BASELINE_Y = 100; const FIELD_L = 96;
  const gorilla = { lane:1, lanes:4, x:FIELD_L, w:60, h:56, invul:0, speed:420, holding:null, t:0 };
  const enemies=[]; const projectiles=[]; const stones=[]; const leaves=[]; const parallax={t1:[],t2:[],vines:[]};
  // состояние анимации смерти
  let death = null; // { t: секунды, dur: секунды, bits:[], shake:число }

  let score=0, lives=3, wave=1, totalToSpawn=100, spawned=0, killed=0, escaped=0, processed=0; let waves=10, spawnTimer=0, spawnInterval=900, gameTime=0, difficulty=DIFF.normal;

  const keys = new Set(); let keyLatch={up:false,down:false,space:false};
  window.addEventListener('keydown', (e)=>{
    if(e.code==='ArrowUp'||e.code==='ArrowDown'||e.code==='Space'||e.code==='Escape'||e.code==='KeyP'){ e.preventDefault(); }
    if(state===STATE.PLAY && (e.code==='Escape' || e.code==='KeyP')){ pauseGame(); return; }
    if(state===STATE.PAUSE && (e.code==='Escape' || e.code==='KeyP')){ resumeGame(); return; }
    keys.add(e.code);
  });
  window.addEventListener('keyup',   (e)=>{ keys.delete(e.code); });

  // === Утилиты ===
  const rnd=(a,b)=>a + Math.random()*(b-a);
  function laneY(i){ return BASELINE_Y + i*LANE_H; }
  function drawRoundedRect(x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.lineTo(x+w-r,y); ctx.quadraticCurveTo(x+w,y,x+w,y+r); ctx.lineTo(x+w,y+h-r); ctx.quadraticCurveTo(x+w,y+h,x+w-r,y+h); ctx.lineTo(x+r,y+h); ctx.quadraticCurveTo(x,y+h,x,y+h-r); ctx.lineTo(x,y+r); ctx.quadraticCurveTo(x,y,x+r,y); ctx.closePath(); }
  function strokeRectRounded(x,y,w,h,r,color,width){ ctx.save(); ctx.lineJoin='round'; ctx.lineWidth=width; ctx.strokeStyle=color; drawRoundedRect(x,y,w,h,r); ctx.stroke(); ctx.restore(); }

  // === Фон «комикс‑джунгли» ===
  function buildParallax(w,h){ parallax.t1.length=0; parallax.t2.length=0; parallax.vines.length=0; for(let i=0;i<10;i++) parallax.t1.push({ x:rnd(0,w), h:rnd(100,180) }); for(let i=0;i<8;i++) parallax.t2.push({ x:rnd(0,w), h:rnd(160,240) }); for(let i=0;i<6;i++) parallax.vines.push({ x:rnd(40,w-40), top:rnd(0,60), len:rnd(90,160) }); }
  function drawParallax(w,h,dt){
    const speed1=10, speed2=18;
    for(const t of parallax.t1){ t.x -= speed1*dt; if(t.x < -24) t.x += w+48; }
    for(const t of parallax.t2){ t.x -= speed2*dt; if(t.x < -24) t.x += w+48; }

    // дальние кроны — заливка + обводка
    ctx.fillStyle = getCss('--canopy-far');
    for(const t of parallax.t1){ drawRoundedRect(t.x-16, 36, 32, t.h, 14); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke(); }
    // средние кроны
    ctx.fillStyle = getCss('--canopy-mid');
    for(const t of parallax.t2){ drawRoundedRect(t.x-20, 24, 40, t.h, 16); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(0,0,0,.4)'; ctx.stroke(); }

    // лианы в стиле комикса
    ctx.strokeStyle = getCss('--vine'); ctx.lineWidth=4; ctx.lineCap='round';
    for(const v of parallax.vines){ ctx.beginPath(); ctx.moveTo(v.x, v.top); const mid = v.top + v.len*0.6; ctx.bezierCurveTo(v.x-30, v.top+v.len*0.2, v.x+30, mid, v.x, v.top+v.len); ctx.stroke(); }
  }
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  function drawBackground(dt){
    const rect=canvas.getBoundingClientRect(); const w=rect.width, h=rect.height;
    // небо/фон
    const g=ctx.createLinearGradient(0,0,0,h); g.addColorStop(0,getCss('--bg-1')); g.addColorStop(1,getCss('--bg-0')); ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
    drawParallax(w,h,dt);
    // земля
    const groundTop=BASELINE_Y-36; ctx.fillStyle=getCss('--dirt'); ctx.fillRect(0,groundTop,w,h-groundTop);
    // дорожки — комикс‑стиль: тело, блик и нижняя тень
    for(let i=0;i<gorilla.lanes;i++){
      const y=laneY(i), y0=y-28, h0=56; const r=8;
      ctx.fillStyle=getCss('--path'); drawRoundedRect(0,y0,w,h0,r); ctx.fill();
      // верхний блик
      ctx.fillStyle=getCss('--path-hi'); ctx.globalAlpha=.18; ctx.fillRect(0,y0, w, 8); ctx.globalAlpha=1;
      // нижняя тень
      ctx.fillStyle=getCss('--path-sh'); ctx.globalAlpha=.18; ctx.fillRect(0,y0+h0-8, w, 8); ctx.globalAlpha=1;
      // тонкая обводка дорожки
      strokeRectRounded(0,y0,w,h0,r,'rgba(0,0,0,.35)',2);
    }
  }

  // === Спрайт гориллы (комикс‑обводка) ===
  function drawGorilla(){
    const y = laneY(gorilla.lane);
    const breath = Math.sin(gorilla.t*3)*1.2;
    // тень
    ctx.fillStyle='rgba(0,0,0,.38)'; ctx.beginPath(); ctx.ellipse(gorilla.x+18, y+24, 34, 11, 0, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(gorilla.x, y+breath);
    // корпус
    ctx.fillStyle = '#2f4639'; drawRoundedRect(-26,-40, 56, 60, 14); ctx.fill(); strokeRectRounded(-26,-40,56,60,14,getCss('--ink'),3);
    // грудь
    ctx.fillStyle = '#466556'; drawRoundedRect(-8,-8, 34, 30, 10); ctx.fill(); strokeRectRounded(-8,-8,34,30,10,getCss('--ink'),2);
    // плечи/руки
    ctx.fillStyle = '#365347'; drawRoundedRect(16,-14, 26, 14, 7); ctx.fill(); strokeRectRounded(16,-14,26,14,7,getCss('--ink'),2);
    ctx.fillStyle = '#365347'; drawRoundedRect(-30,-16, 24, 14, 7); ctx.fill(); strokeRectRounded(-30,-16,24,14,7,getCss('--ink'),2);
    // голова
    ctx.save(); ctx.translate(22,-30);
    ctx.fillStyle = '#3a584a'; drawRoundedRect(-4,-8, 24, 22, 8); ctx.fill(); strokeRectRounded(-4,-8,24,22,8,getCss('--ink'),2);
    ctx.fillStyle = '#7c9b8d'; drawRoundedRect(2,-2, 16, 10, 4); ctx.fill(); strokeRectRounded(2,-2,16,10,4,getCss('--ink'),1.5);
    ctx.fillStyle = '#24352d'; ctx.fillRect(10,2,4,3);
    ctx.fillStyle = '#e9f4ee'; ctx.fillRect(4,-4,3,3); ctx.fillRect(14,-4,3,3);
    ctx.restore();
    // предмет в руках
    if(gorilla.holding){
      ctx.fillStyle = '#365347'; drawRoundedRect(18,-6, 26, 12, 6); ctx.fill(); strokeRectRounded(18,-6,26,12,6,getCss('--ink'),2);
      ctx.fillStyle = '#365347'; drawRoundedRect(4,-8, 22, 12, 6); ctx.fill(); strokeRectRounded(4,-8,22,12,6,getCss('--ink'),2);
      if(gorilla.holding.kind==='stone'){
        ctx.fillStyle = '#b2966a';
        ctx.beginPath(); ctx.arc(44,-4, 10, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=getCss('--ink'); ctx.stroke();
      } else {
        drawHumanoidBody(44,-4, gorilla.holding.mass==='heavy' ? 1.15 : 1.0, -0.2);
      }
    }
    ctx.restore();
    // рамка при неуязвимости
    if(gorilla.invul>0){ ctx.strokeStyle='rgba(255,180,180,.9)'; ctx.lineWidth=2; ctx.strokeRect(gorilla.x-30, y-50, 80, 80); }
  }

  // === Враги и их рисунок ===
  function enemyColors(type){ switch(type){
    case 'sprinter': return { body:'#f5d5b0', shirt:'#a2ed6c' };
    case 'zigzag':   return { body:'#f0d0b0', shirt:'#ffd166' };
    case 'heavy':    return { body:'#ecc8a3', shirt:'#e07a63' };
    case 'thrower':  return { body:'#f0d7b8', shirt:'#7db7f0' };
    default:         return { body:'#f0d7b8', shirt:'#d0c47a' };
  } }
  function drawEnemy(e){
    const y=laneY(e.lane); const c=enemyColors(e.type);
    // тень
    ctx.fillStyle='rgba(0,0,0,.32)'; ctx.beginPath(); ctx.ellipse(e.x, y+18, 22, 8, 0, 0, Math.PI*2); ctx.fill();
    // ноги
    ctx.fillStyle='#27221a'; ctx.fillRect(e.x-10, y-8, 8, 16); ctx.fillRect(e.x+2, y-8, 8, 16);
    // туловище
    ctx.fillStyle=c.shirt; drawRoundedRect(e.x-12, y-28, 24, 26, 6); ctx.fill(); strokeRectRounded(e.x-12, y-28,24,26,6,getCss('--ink'),2);
    // голова
    ctx.fillStyle=c.body; ctx.beginPath(); ctx.arc(e.x, y-36, 8, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=getCss('--ink'); ctx.stroke();

    // телеграф метателя — «!» янтарного цвета с лёгким контуром
    if(e.type==='thrower' && e.state==='tele'){
      ctx.save(); ctx.translate(e.x, y-48); ctx.fillStyle=getCss('--warn');
      ctx.fillRect(-2,-6,4,8); ctx.fillRect(-2,4,4,2); // «!»
      ctx.lineWidth=1.5; ctx.strokeStyle='rgba(0,0,0,.45)'; ctx.strokeRect(-3,-7,6,14);
      ctx.restore();
    }
  }

  function drawHumanoidBody(x, y, size, angle, shirt, skin){
    shirt = shirt || '#d0c47a';
    skin  = skin  || '#f0d7b8';
    ctx.save();
    ctx.translate(x,y);
    if(angle) ctx.rotate(angle);
    // туловище
    ctx.fillStyle = shirt;
    drawRoundedRect(-10*size, -8*size, 20*size, 16*size, 6*size); ctx.fill();
    strokeRectRounded(-10*size, -8*size, 20*size, 16*size, 6*size, getCss('--ink'), 2);
    // голова
    ctx.fillStyle = skin; ctx.beginPath(); ctx.arc(0, -12*size, 6*size, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=getCss('--ink'); ctx.stroke();
    // руки
    ctx.fillStyle = shirt; drawRoundedRect(-16*size, -6*size, 6*size, 4*size, 2*size); ctx.fill(); drawRoundedRect(10*size, -6*size, 6*size, 4*size, 2*size); ctx.fill();
    // ноги
    ctx.fillStyle = '#27221a'; drawRoundedRect(-6*size, 6*size, 6*size, 6*size, 2*size); ctx.fill(); drawRoundedRect(0, 6*size, 6*size, 6*size, 2*size); ctx.fill();
    ctx.restore();
  }

  function drawProjectile(p){ const y=laneY(p.lane); if(p.kind==='stone'){ const g=ctx.createRadialGradient(p.x-3,y-20,2, p.x,y-18,p.r); g.addColorStop(0,'#e2d2ad'); g.addColorStop(1,'#b2966a'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(p.x, y-18, p.r, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=getCss('--ink'); ctx.stroke(); } else { const size = (p.r>=12? 1.15 : 1.0); const angle = 0.35 * Math.sin((window.gameTime||0)*7 + (p.spin||0)); drawHumanoidBody(p.x, y-12, size, angle); ctx.save(); ctx.globalAlpha = 0.12; ctx.fillStyle = '#eaf7ef'; ctx.fillRect(p.x-28, y-14, 24, 4); ctx.restore(); } }

  function drawStone(s){ const y=laneY(s.lane); const g=ctx.createRadialGradient(s.x-3,y-20,2, s.x,y-18,8); g.addColorStop(0,'#e2d2ad'); g.addColorStop(1,'#a88a5f'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(s.x, y-18, 8, 0, Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle=getCss('--ink'); ctx.stroke(); }

  // === Игровая логика (как в Fixes B) ===
  function rectsOverlap(ax,aw,bx,bw){ return Math.abs(ax-bx) < (aw/2 + bw/2); }

  function spawnEnemy(){ if(spawned >= totalToSpawn) return; const lane = Math.floor(Math.random()*gorilla.lanes); const wv=wave; const allowThrower = (wv >= difficulty.startThrowersWave); const pool=[]; pool.push(['runner',50]); pool.push(['sprinter',10 + Math.max(0,wv-3)*4]); pool.push(['zigzag',   8  + Math.max(0,wv-2)*3]); pool.push(['heavy',    8  + Math.max(0,wv-4)*3]); if(allowThrower) pool.push(['thrower', 6 + Math.max(0,wv-5)*3]); const sum = pool.reduce((s,[,v])=>s+v,0); let r=Math.random()*sum, type='runner'; for(const [t,v] of pool){ r-=v; if(r<=0){ type=t; break; } }
    const baseSpeed=92 * difficulty.speedMul; let speed=baseSpeed; if(type==='sprinter') speed*=1.9; else if(type==='heavy') speed*=0.64; else if(type==='thrower') speed*=0.95; else if(type==='zigzag') speed*=1.07; const rect=canvas.getBoundingClientRect(); const e={ type, lane, x: rect.width + 40, w:22, h:34, speed, zigTimer: 0.6 + Math.random()*0.6, state:'run', teleTimer:difficulty.throwerTele, stopX: Math.max(320, 520 - wv*8 + Math.random()*60), };
    enemies.push(e); spawned++; }

  let lastTs=0;
  function loop(ts){ requestAnimationFrame(loop); if(state!==STATE.PLAY && state!==STATE.DEATH) return; fitHiDPI(); const rect=canvas.getBoundingClientRect(); const w=rect.width, h=rect.height; const dt=Math.min(0.033, (ts - lastTs)/1000 || 0); lastTs=ts; gameTime+=dt; gorilla.t += dt;
    // Если идёт анимация смерти — рисуем её и выходим
    if(state===STATE.DEATH && death){
      const rect=canvas.getBoundingClientRect(); const w=rect.width, h=rect
    if(keys.has('ArrowUp') && !keyLatch.up){ gorilla.lane=Math.max(0, gorilla.lane-1); keyLatch.up=true; } if(!keys.has('ArrowUp')) keyLatch.up=false;
    if(keys.has('ArrowDown') && !keyLatch.down){ gorilla.lane=Math.min(gorilla.lanes-1, gorilla.lane+1); keyLatch.down=true; } if(!keys.has('ArrowDown')) keyLatch.down=false;

    if(keys.has('Space') && !keyLatch.space){ keyLatch.space=true; if(gorilla.holding){ const p={ kind:gorilla.holding.kind, lane: gorilla.lane, x: gorilla.x+50, vx: 540, r: gorilla.holding.kind==='stone'? 8 : (gorilla.holding.mass==='heavy'? 12 : 10), spin: Math.random()*Math.PI*2 }; projectiles.push(p); gorilla.holding=null; } else { let target=null, minDx=9999; for(const e of enemies){ if(e.lane!==gorilla.lane) continue; const dx=e.x-(gorilla.x+22); if(dx>=-6 && dx<minDx && dx<62){ target=e; minDx=dx; } } if(target){ const idx=enemies.indexOf(target); if(idx>=0) enemies.splice(idx,1); gorilla.holding={ kind:'body', lane:gorilla.lane, mass: target.type==='heavy'?'heavy':'normal' }; processed++; } else { for(let i=0;i<stones.length;i++){ const s=stones[i]; if(s.lane!==gorilla.lane) continue; const dx=Math.abs(s.x-(gorilla.x+24)); if(dx<26){ gorilla.holding={kind:'stone',lane:gorilla.lane}; stones.splice(i,1); break; } } } }
    }
    if(!keys.has('Space')) keyLatch.space=false;

    if(gorilla.invul>0) gorilla.invul = Math.max(0, gorilla.invul - dt);

    spawnTimer -= dt*1000; if(spawnTimer<=0){ spawnEnemy(); const waveP = (spawned)/(totalToSpawn); const waveIdx = Math.floor(waveP * waves) + 1; spawnInterval = difficulty.spawnBase - (waveIdx-1)*40; spawnTimer = Math.max(260, spawnInterval + (Math.random()*120-60)); }

    for(let i=enemies.length-1;i>=0;i--){ const e=enemies[i]; if(e.type==='zigzag'){ e.zigTimer -= dt; if(e.zigTimer<=0){ e.zigTimer=0.45+Math.random()*0.7; const dir=Math.random()<.5?-1:1; e.lane=Math.min(gorilla.lanes-1, Math.max(0, e.lane+dir)); } }
      if(e.type==='thrower'){
        if(e.state==='run'){ e.x -= e.speed*dt; if(e.x<=e.stopX){ e.state='tele'; e.teleTimer = difficulty.throwerTele; } }
        else if(e.state==='tele'){ e.teleTimer -= dt; if(e.teleTimer<=0){ e.state='throw'; } }
        else if(e.state==='throw'){ stones.push({ lane:e.lane, x:e.x-10, vx: -430 * difficulty.speedMul }); e.state='resume'; }
        else if(e.state==='resume'){ e.x -= e.speed*dt*0.95; }
      } else { e.x -= e.speed*dt; }

      if(e.lane===gorilla.lane && !gorilla.holding){ if(rectsOverlap(e.x, 22, gorilla.x+18, 40)){ if(gorilla.invul<=0){ lives--; gorilla.invul=0.9; flashLives(); } enemies.splice(i,1); processed++; } }
      if(e && e.x < -30){ enemies.splice(i,1); escaped++; processed++; }
    }

    for(let i=stones.length-1;i>=0;i--){ const s=stones[i]; s.x += s.vx*dt; if(s.lane===gorilla.lane && Math.abs(s.x-(gorilla.x+22))<16){ if(keys.has('Space') && !gorilla.holding){ gorilla.holding={kind:'stone',lane:gorilla.lane}; stones.splice(i,1); continue; } if(gorilla.invul<=0){ lives--; gorilla.invul=0.9; flashLives(); } stones.splice(i,1); } if(s.x < -40) stones.splice(i,1); }

    for(let i=projectiles.length-1;i>=0;i--){ const p=projectiles[i]; p.x += p.vx*dt; for(let j=enemies.length-1;j>=0;j--){ const e=enemies[j]; if(e.lane!==p.lane) continue; if(Math.abs(p.x - e.x) < (p.r + 11)){ enemies.splice(j,1); killed++; processed++; score++; if(p.kind==='body' && p.r>10) p.vx *= 0.97; } } if(p.x > w+40) projectiles.splice(i,1); }

    const newWave = Math.floor(processed / Math.max(1, Math.ceil(totalToSpawn / waves))) + 1; wave = Math.min(waves, newWave); if(lives<=0 || processed>=totalToSpawn){ endRound(lives>0); return; }

    ctx.clearRect(0,0,w,h); drawBackground(dt); for(const e of enemies) drawEnemy(e); for(const s of stones) drawStone(s); for(const p of projectiles) drawProjectile(p); drawGorilla();
    hud.score.textContent = `Счёт: ${score}`; hud.lives.textContent = `Жизни: ${Math.max(0,lives)}`; hud.wave.textContent = `Волна: ${wave}/${waves}`; hud.left.textContent = `Осталось: ${Math.max(0,totalToSpawn-processed)}`;
  }

  function flashLives(){ hud.lives.classList.add('danger'); setTimeout(()=>hud.lives.classList.remove('danger'), 240); }
  function pauseGame(){ state=STATE.PAUSE; screenPause.classList.add('active'); }
  function resumeGame(){ if(state===STATE.PAUSE){ state=STATE.PLAY; screenPause.classList.remove('active'); requestAnimationFrame(loop); } }
  function startGame(diffKey){ lastDiff=diffKey; difficulty=DIFF[diffKey]||DIFF.normal; state=STATE.PLAY; screenStart.classList.remove('active'); screenOver.classList.remove('active'); screenPause.classList.remove('active'); hud.root.hidden=false; hud.tr.hidden=false; hud.diff.textContent=difficulty.name; gorilla.lanes=difficulty.lanes; gorilla.lane=Math.floor(gorilla.lanes/2); gorilla.holding=null; gorilla.invul=0; gorilla.speed=420*difficulty.gorillaSpeed; gorilla.t=0; enemies.length=0; projectiles.length=0; stones.length=0; leaves.length=0; buildParallax(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height); score=0; lives=difficulty.lives; wave=1; totalToSpawn=difficulty.total; waves=difficulty.waves; spawned=0; killed=0; escaped=0; processed=0; gameTime=0; spawnTimer=300; spawnInterval=difficulty.spawnBase; fitHiDPI(); lastTs=performance.now(); requestAnimationFrame(loop); }
  function collectMedals(){ const medals=[]; if(killed>=80 && !difficulty.practice) medals.push('Гроза толпы (80+)'); if(lives===difficulty.lives && !difficulty.practice) medals.push('Без царапин'); if(score>=killed && score>0 && !difficulty.practice) medals.push('Каждый — броском'); if(difficulty.name==='Тяжело' && lives>0) medals.push('Железные нервы'); return medals; }
  function endRound(won){ state=STATE.OVER; hud.root.hidden=true; hud.tr.hidden=true; over.title.textContent=(won?'Победа!':'Горилла пала…'); over.score.textContent=score; over.lives.textContent=Math.max(0,lives); over.waves.textContent=`${wave}/${waves}`; over.killed.textContent=`${killed}/${totalToSpawn}`; over.medals.innerHTML=''; for(const m of collectMedals()){ const s=document.createElement('span'); s.className='badge'; s.textContent=m; over.medals.appendChild(s);} if(!difficulty.practice){ saveBest(score);} bestLine.textContent='Лучший счёт: '+loadBest(); screenOver.classList.add('active'); }
  function backToMenu(){ state=STATE.MENU; hud.root.hidden=true; hud.tr.hidden=true; hud.score.textContent='Счёт: 0'; hud.lives.textContent='Жизни: 0'; hud.wave.textContent='Волна: 0/0'; hud.left.textContent='Осталось: 0'; screenPause.classList.remove('active'); screenOver.classList.remove('active'); screenStart.classList.add('active'); loadBest(); }

  // === Тесты — открыть index.html#test ===
  function runTests(){ const logEl=document.getElementById('testlog'); const logs=[]; const ok=m=>logs.push('✅ '+m); const fail=m=>logs.push('❌ '+m);
    rectsOverlap(10,10,18,10) ? ok('rectsOverlap: пересекаются') : fail('rectsOverlap: ожидали пересечение');
    !rectsOverlap(0,10,40,10) ? ok('rectsOverlap: не пересекаются') : fail('rectsOverlap: не должно пересекаться');
    let got=false; const savedWave=wave; wave=6; for(let k=0;k<200;k++){ spawnEnemy(); const e=enemies.pop(); if(e && e.type==='thrower'){ got=true; break; } } wave=savedWave; got ? ok('spawnEnemy: метатели после нужной волны') : fail('spawnEnemy: нет метателя на волне >=6');
    const prevProcessed=processed; gorilla.lane=0; enemies.push({type:'runner', lane:0, x:gorilla.x+30, w:22, h:34, speed:0, zigTimer:1, state:'run', teleTimer:0, stopX:0}); let target=null, minDx=9999; for(const e of enemies){ if(e.lane!==gorilla.lane) continue; const dx=e.x-(gorilla.x+22); if(dx>=-6 && dx<minDx && dx<62){ target=e; minDx=dx; } } if(target){ const idx=enemies.indexOf(target); if(idx>=0) enemies.splice(idx,1); gorilla.holding={ kind:'body', lane:gorilla.lane, mass:'normal' }; processed++; } (processed===prevProcessed+1) ? ok('Захват увеличивает processed') : fail('Захват должен увеличивать processed');
    const livesBefore=lives; const enemiesCnt=enemies.length, stonesCnt=stones.length; const hadHolding = !!gorilla.holding; gorilla.holding=null; if(enemiesCnt===0 && stonesCnt===0){} (lives===livesBefore) ? ok('Пробел на пустом поле не отнимает жизнь') : fail('Пробел не должен отнимать жизнь');
    logEl.style.display='block'; logEl.innerText = logs.join('\n'); }
  if(location.hash==="#test"){ runTests(); }

  // Красиво на старте
  fitHiDPI(); buildParallax(canvas.getBoundingClientRect().width, canvas.getBoundingClientRect().height);
  (function first(){ const rect=canvas.getBoundingClientRect(); ctx.clearRect(0,0,rect.width,rect.height); const dt=0.016; drawBackground(dt); drawGorilla(); })();
})();
</script>
</body>
</html>
